using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using CACO_Patcher.Utilities;
using static CACO_Patcher.Utilities.RecordUtilities;
using static CACO_Patcher.Utilities.LeveledListUtilities;
using CACO_Patcher.Settings;
using System.Collections.Generic;
using Noggog;
using Mutagen.Bethesda.Plugins.Records;
using System;
using Mutagen.Bethesda.Plugins.Aspects;
using DynamicData;
using Mutagen.Bethesda.Plugins.Cache;
using static Mutagen.Bethesda.Skyrim.Furniture;
using Mutagen.Bethesda.Strings;
using CommandLine;
using System.Data.SqlTypes;

namespace CACO_Patcher {
    public class Program {

        private static Lazy<Settings.Settings> _settings = null!;
        private const string CACOPatchName = "CACO_Auto_Patcher.esp";
        public static async Task<int> Main(string[] args) {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch, new PatcherPreferences()
                {
                    ExclusionMods = new List<ModKey>()
                    {
                         new ModKey(CACOPatchName, ModType.Plugin),
                         new ModKey("Synthesis.esp", ModType.Plugin),
                         new ModKey("Requiem for the Indifferent.esp", ModType.Plugin)
                    }
                })
                .SetTypicalOpen(GameRelease.SkyrimSE, CACOPatchName)
                .SetAutogeneratedSettings("settings", "settings.json", out _settings)
                .Run(args);
        }
        public static String GetBaseModName() {
            return _settings.Value.CacoBaseModName;
        }
        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) {
            System.Console.WriteLine("Running version: 0.1");
            List<ModKey> allmods = new List<ModKey>();
            foreach (var mod in state.LoadOrder) {
                allmods.Add(mod.Key);
                System.Console.WriteLine(mod.Key);
            }
            if (allmods.Contains("Requiem for the Indifferent.esp")) {
                System.Console.WriteLine("\"Reqiem for the Indifferent.esp\", did not get filtered out, cannot run.");
            }
            //get CACO
            ISkyrimModGetter? CACO = state.LoadOrder.getModByFileName(_settings.Value.CacoBaseModName);
            if (CACO is null) {
                System.Console.WriteLine("CACO not found and initial check did not see that- Please enable CACO and notify mod author that this happened, because it shouldn't.");
                throw new Exception();
            }

            //get list of CACO and all its patches
            (List<String> modNames, List<ISkyrimModGetter> mods) = state.LoadOrder.getModsFromMasterIncludingMaster(_settings.Value.CacoBaseModName, CACO);
            //reverse to make sure we always patch the most recent override in the CACO inheritence tree
            modNames.Reverse();
            mods.Reverse();
            if (_settings.Value.PatchIngestibles) {
                patchIngestibles(state, modNames, mods);
            }
            if (_settings.Value.PatchBooks) {
                patchBooks(state, modNames, mods);
            }
            if (_settings.Value.PatchRecipies) {
                patchRecipies(state, modNames, mods);
            }
            if (_settings.Value.PatchLootables) {
                patchLootables(state, modNames, mods);
            }
            if (_settings.Value.PatchFlora) {
                patchFlora(state, modNames, mods);
            }
            if (_settings.Value.PatchFormIdLists) {
                patchFormIDLists(state, modNames, mods);
            }
            if (_settings.Value.PatchAlchemySkillFactor) {
                patchAlchemySkillFactor(state, modNames, mods);
            }
            if (_settings.Value.PatchIngredients) {
                patchIngredients(state, modNames, mods);
            }
            if (_settings.Value.PatchLeveledItems) {
                patchLeveledItems(state, modNames, mods);
            }
            if (_settings.Value.PatchMessages) {
                patchMessages(state, modNames, mods);
            }
            if (_settings.Value.PatchMagicEffects) {
                patchMagicEffects(state, modNames, mods);
            }
            if (_settings.Value.PatchMiscItems) {
                patchMiscItems(state, modNames, mods);
            }
            if (_settings.Value.PatchNpcs) {
                patchNpcs(state, modNames, mods);
            }
            if (_settings.Value.PatchPerks) {
                patchPerks(state, modNames, mods);
            }
            if (_settings.Value.PatchQuests) {
                patchQuests(state, modNames, mods);
            }
            if (_settings.Value.PatchSpells) {
                patchSpells(state, modNames, mods);
            }
            if (_settings.Value.PatchTrees) {
                patchTrees(state, modNames, mods);
            }
        }
        public static void patchIngestibles(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching ingestibles...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Ingestibles.Select(x => x.FormKey).ToList();
                List<IIngestibleGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IIngestibleGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IIngestibleGetter ingestible in mod.Ingestibles) {

                    //check if a higher-priority version of this record has already been processed
                    if (alreadyProcessed.Contains(ingestible.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(ingestible.FormKey);
                    IIngestibleGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == ingestible.FormKey).First();
                    Ingestible patchIngestible = state.PatchMod.Ingestibles.GetOrAddAsOverride(winningOverrideRecord);

                    //find base ingestible in files
                    (IIngestibleGetter baseRecord, bool inBaseGameFiles) = ((IIngestibleGetter, bool))GetBaseRecord(ingestible.FormKey, masters.Select(x => x?.Ingestibles), mod.Ingestibles);
                    
                    //override name
                    if (ingestible.Name is not null) {
                        patchIngestible.Name = ingestible.Name.DeepCopy();
                    }

                    //merge keywords
                    //Did you create a type-agnostic FormLink list merging function?
                    //Yes.
                    //What did it cost?
                    //Everything.
                    //patchIngestible.Keywords?.SetTo(_MergeFormLinkList(state.LinkCache, inBaseGameFiles, ingestible.Keywords, baseRecord?.Keywords, winningOverrideRecord.Keywords, patchIngestible.Keywords?.Cast<IFormLinkGetter<IMajorRecordGetter>>().ToExtendedList())?.Cast<IFormLinkGetter<IKeywordGetter>>().ToExtendedList() ?? patchIngestible.Keywords ?? new ExtendedList<IFormLinkGetter<IKeywordGetter>>());
                    //merge keywords
                    if (ingestible.Keywords is not null) {
                        if (patchIngestible.Keywords is null) {
                            patchIngestible.Keywords = new();
                        }
                        patchIngestible.Keywords.SetTo(MergeKeywordList(ingestible.Keywords, baseRecord.Keywords, patchIngestible.Keywords));
                    }
                    //override model
                    if (ingestible.Model is not null) {
                        patchIngestible.Model = ingestible.Model.DeepCopy();
                    }

                    //override sounds
                    patchIngestible.PickUpSound.SetTo(ingestible.PickUpSound);
                    patchIngestible.PutDownSound.SetTo(ingestible.PutDownSound);
                    patchIngestible.ConsumeSound.SetTo(ingestible.ConsumeSound);

                    //override weight
                    patchIngestible.Weight = ingestible.Weight;

                    //override value
                    patchIngestible.Value = ingestible.Value;

                    //set flags
                    if (ingestible.Flags.HasFlag(Ingestible.Flag.NoAutoCalc) && !winningOverrideRecord.Flags.HasFlag(Ingestible.Flag.NoAutoCalc)) {
                        patchIngestible.Flags = patchIngestible.Flags.SetFlag(Ingestible.Flag.NoAutoCalc, true);
                    }
                    if (ingestible.Flags.HasFlag(Ingestible.Flag.FoodItem) && !winningOverrideRecord.Flags.HasFlag(Ingestible.Flag.FoodItem)) {
                        patchIngestible.Flags = patchIngestible.Flags.SetFlag(Ingestible.Flag.FoodItem, true);
                    }

                    //patch object bounds, override if it's not the vanilla bounds
                    if (baseRecord is not null && !ingestible.ObjectBounds.Equals(baseRecord.ObjectBounds)) {
                        patchIngestible.ObjectBounds = ingestible.ObjectBounds.DeepCopy();
                    }

                    //override effects
                    patchIngestible.Effects.Clear();
                    foreach (IEffectGetter e in ingestible.Effects) {
                        patchIngestible.Effects.Add(e.DeepCopy());
                    }
                }
            }
        }
        public static void patchBooks(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching books...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Books.Select(x => x.FormKey).ToList();
                List<IBookGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IBookGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IBookGetter book in mod.Books) {
                    if (alreadyProcessed.Contains(book.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(book.FormKey);
                    IBookGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == book.FormKey).First();
                    Book patchBook = state.PatchMod.Books.GetOrAddAsOverride(winningOverrideRecord);

                    //find base book in files
                    (IBookGetter baseRecord, bool inBaseGameFiles) = ((IBookGetter, bool))GetBaseRecord(book.FormKey, masters.Select(x => x?.Books), mod.Books);
                    System.Console.WriteLine("Patching book: " + book.EditorID);

                    //override editor ID
                    patchBook.EditorID = book.EditorID;

                    //override name
                    if (book.Name is not null) {
                        patchBook.Name = book.Name.DeepCopy();
                    }

                    //override value
                    patchBook.Value = book.Value;

                    //override model
                    if (book.Model is not null) {
                        patchBook.Model = book.Model.DeepCopy();
                    }

                    //override inventory art
                    patchBook.InventoryArt.SetTo(book.InventoryArt);

                    //override book text
                    patchBook.BookText = book.BookText.DeepCopy();

                    //merge virtual machine adapter
                    patchBook.VirtualMachineAdapter = MergeVMAdapters(book.VirtualMachineAdapter, baseRecord, patchBook.VirtualMachineAdapter);
                }
            }
        }
        public static void patchRecipies(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching recipies...");
            int modIndex = -1;
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.ConstructibleObjects.Select(x => x.FormKey).ToList();
                List<IConstructibleObjectGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IConstructibleObjectGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                foreach (IConstructibleObjectGetter constructibleObject in mod.ConstructibleObjects) {
                    IConstructibleObjectGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == constructibleObject.FormKey).First();
                    ConstructibleObject patchConstructibleObject = state.PatchMod.ConstructibleObjects.GetOrAddAsOverride(winningOverrideRecord);

                    //override items
                    if (patchConstructibleObject.Items is null) {
                        patchConstructibleObject.Items ??= new();
                    }
                    patchConstructibleObject.Items.Clear();
                    if (constructibleObject.Items is not null) {
                        foreach (IContainerEntryGetter item in constructibleObject.Items) {
                            patchConstructibleObject.Items.Add(item.DeepCopy());
                        }
                    }

                    //override created object
                    patchConstructibleObject.CreatedObject.SetTo(constructibleObject.CreatedObject);

                    //override created object count
                    patchConstructibleObject.CreatedObjectCount = constructibleObject.CreatedObjectCount;

                    //override conditions
                    patchConstructibleObject.Conditions.Clear();
                    if (constructibleObject.Conditions is not null) {
                        foreach (IConditionGetter condition in constructibleObject.Conditions) {
                            patchConstructibleObject.Conditions.Add(condition.DeepCopy());
                        }
                    }
                }
            }
        }
        public static void patchLootables(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching lootables...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Containers.Select(x => x.FormKey).ToList();
                List<IContainerGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IContainerGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IContainerGetter container in mod.Containers) {
                    if (alreadyProcessed.Contains(container.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(container.FormKey);
                    //pull container from the base game files for comparison

                    IContainerGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == container.FormKey).First();
                    Container patchContainer = state.PatchMod.Containers.GetOrAddAsOverride(winningOverrideRecord);
                    
                    //find base container in files
                    (IContainerGetter baseRecord, bool inBaseGameFiles) = ((IContainerGetter, bool))GetBaseRecord(container.FormKey, masters.Select(x => x?.Containers), mod.Containers);

                    //merge items
                    if (patchContainer.Items is null) {
                        patchContainer.Items = new();
                    }
                    patchContainer.Items.SetTo(MergeContainerEntryList(container.Items, baseRecord.Items, patchContainer.Items));
                    
                    //patch object bounds, override if it's not the vanilla bounds
                    if (!container.ObjectBounds.Equals(baseRecord)) {
                        patchContainer.ObjectBounds = container.ObjectBounds.DeepCopy();
                    }

                    //merge scripts
                    patchContainer.VirtualMachineAdapter = MergeVMAdapters(container.VirtualMachineAdapter, baseRecord, patchContainer.VirtualMachineAdapter);

                    //patch flags
                    if (container.Flags.HasFlag(Container.Flag.Respawns) && !winningOverrideRecord.Flags.HasFlag(Container.Flag.Respawns)) {
                        patchContainer.Flags = patchContainer.Flags.SetFlag(Container.Flag.Respawns, true);
                    }
                }
            }
        }
        public static void patchFlora(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching flora...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Florae.Select(x => x.FormKey).ToList();
                List<IFloraGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IFloraGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IFloraGetter flora in mod.Florae) {
                    if (alreadyProcessed.Contains(flora.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(flora.FormKey);
                    IFloraGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == flora.FormKey).First();
                    Flora patchFlora = state.PatchMod.Florae.GetOrAddAsOverride(winningOverrideRecord);

                    //find base flora in files
                    (IFloraGetter baseRecord, bool inBaseGameFiles) = ((IFloraGetter, bool))GetBaseRecord(flora.FormKey, masters.Select(x => x?.Florae), mod.Florae);

                    // merge scripts
                    patchFlora.VirtualMachineAdapter = MergeVMAdapters(flora.VirtualMachineAdapter, baseRecord, patchFlora.VirtualMachineAdapter);

                    //override activate text override
                    if (flora.ActivateTextOverride is not null) {
                        patchFlora.ActivateTextOverride = flora.ActivateTextOverride.DeepCopy();
                    }

                    //override ingredient
                    patchFlora.Ingredient.SetTo(flora.Ingredient);
                }
            }
        }
        public static void patchFormIDLists(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching formID lists...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.FormLists.Select(x => x.FormKey).ToList();
                List<IFormListGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IFormListGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                foreach (IFormListGetter formList in mod.FormLists) {
                    if (alreadyProcessed.Contains(formList.FormKey)) {
                        continue;
                    }

                    alreadyProcessed.Add(formList.FormKey);
                    IFormListGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == formList.FormKey).First();

                    FormList patchFormList = state.PatchMod.FormLists.GetOrAddAsOverride(winningOverrideRecord);

                    //union, copy to avoid enumeration modified error
                    ExtendedList<IFormLinkGetter<ISkyrimMajorRecordGetter>> patchFormListItemsCopy = new ExtendedList<IFormLinkGetter<ISkyrimMajorRecordGetter>>(patchFormList.Items);
                    patchFormList.Items.SetTo(patchFormListItemsCopy.Union(formList.Items));
                }
            }
        }
        public static void patchAlchemySkillFactor(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching alchemy skill factor...");
            int modIndex = -1;
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.GameSettings.Select(x => x.FormKey).ToList();
                List<IGameSettingGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IGameSettingGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                foreach (IGameSettingGetter gameSetting in mod.GameSettings) {
                    state.PatchMod.GameSettings.GetOrAddAsOverride(gameSetting);
                }
            }
        }
        public static void patchIngredients(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching ingredients...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Ingredients.Select(x => x.FormKey).ToList();
                List<IIngredientGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IIngredientGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IIngredientGetter ingredient in mod.Ingredients) {
                    if (alreadyProcessed.Contains(ingredient.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(ingredient.FormKey);
                    IIngredientGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == ingredient.FormKey).First();
                    Ingredient patchIngredient = state.PatchMod.Ingredients.GetOrAddAsOverride(winningOverrideRecord);

                    //find base ingredient in files
                    (IIngredientGetter baseRecord, bool inBaseGameFiles) = ((IIngredientGetter, bool))GetBaseRecord(ingredient.FormKey, masters.Select(x => x?.Ingredients), mod.Ingredients);

                    //override effects
                    patchIngredient.Effects.Clear();
                    foreach (IEffectGetter e in ingredient.Effects) {
                        patchIngredient.Effects.Add(e.DeepCopy());
                    }

                    //override sounds
                    patchIngredient.PickUpSound.SetTo(ingredient.PickUpSound);
                    patchIngredient.PutDownSound.SetTo(ingredient.PutDownSound);

                    //override data
                    patchIngredient.Value = ingredient.Value;
                    patchIngredient.Weight = ingredient.Weight;

                    //override effect data
                    patchIngredient.IngredientValue = ingredient.IngredientValue;

                    //override model
                    patchIngredient.Model = ingredient.Model?.DeepCopy();

                    //patch object bounds, override if it's not the vanilla bounds
                    if (!ingredient.ObjectBounds.Equals(baseRecord.ObjectBounds)) {
                        patchIngredient.ObjectBounds = ingredient.ObjectBounds.DeepCopy();
                    }

                    //patch name
                    patchIngredient.Name = ingredient.Name?.DeepCopy();

                    //set flags
                    if (ingredient.Flags.HasFlag(Ingredient.Flag.NoAutoCalculation) && !winningOverrideRecord.Flags.HasFlag(Ingredient.Flag.NoAutoCalculation)) {
                        patchIngredient.Flags = patchIngredient.Flags.SetFlag(Ingredient.Flag.NoAutoCalculation, true);
                    }
                    if (ingredient.Flags.HasFlag(Ingredient.Flag.FoodItem) && !winningOverrideRecord.Flags.HasFlag(Ingredient.Flag.FoodItem)) {
                        patchIngredient.Flags = patchIngredient.Flags.SetFlag(Ingredient.Flag.FoodItem, true);
                    }

                    //patch keywords
                    //patchIngredient.Keywords?.SetTo(_mergeFormLinkList(state.LinkCache, inBaseGameFiles, ingredient.Keywords, baseRecord?.Keywords, winningOverrideRecord.Keywords, patchIngredient.Keywords?.Cast<IFormLinkGetter<IMajorRecordGetter>>().ToExtendedList())?.Cast<IFormLinkGetter<IKeywordGetter>>().ToExtendedList() ?? patchIngredient.Keywords ?? new ExtendedList<IFormLinkGetter<IKeywordGetter>>());
                    //merge keywords
                    if (ingredient.Keywords is not null) {
                        if (patchIngredient.Keywords is null) {
                            patchIngredient.Keywords = new();
                        }
                        patchIngredient.Keywords.SetTo(MergeKeywordList(ingredient.Keywords, baseRecord.Keywords, patchIngredient.Keywords));
                    }
                }
            }
        }
        public static void patchLeveledItems(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching leveled items...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.LeveledItems.Select(x => x.FormKey).ToList();
                List<ILeveledItemGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<ILeveledItemGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (ILeveledItemGetter leveledItem in mod.LeveledItems) {
                    if (alreadyProcessed.Contains(leveledItem.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(leveledItem.FormKey);
                    ILeveledItemGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == leveledItem.FormKey).First();
                    LeveledItem patchLeveledItem = state.PatchMod.LeveledItems.GetOrAddAsOverride(winningOverrideRecord);

                    //find base LeveledItem in files
                    (ILeveledItemGetter baseRecord, bool inBaseGameFiles) = ((ILeveledItemGetter, bool))GetBaseRecord(leveledItem.FormKey, masters.Select(x => x?.LeveledItems), mod.LeveledItems);

                    //merge entries
                    //this function took a week to make
                    patchLeveledItem.Entries = MergeLeveledList(leveledItem.Entries, baseRecord.Entries, patchLeveledItem.Entries);

                    //override global
                    patchLeveledItem.Global.SetTo(leveledItem.Global);

                    //override flags
                    patchLeveledItem.Flags = leveledItem.Flags;

                    //patch chance none, allow other mods to override
                    
                    if (!(patchLeveledItem.ChanceNone == baseRecord.ChanceNone)) {
                        patchLeveledItem.ChanceNone = leveledItem.ChanceNone;
                    }
                }
            }
        }
        public static void patchMessages(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching messagess...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Messages.Select(x => x.FormKey).ToList();
                List<IMessageGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IMessageGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IMessageGetter message in mod.Messages) {
                    if (alreadyProcessed.Contains(message.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(message.FormKey);
                    IMessageGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == message.FormKey).First();
                    Message patchMessage = state.PatchMod.Messages.GetOrAddAsOverride(winningOverrideRecord);

                    //find base message in files
                    (IMessageGetter baseRecord, bool inBaseGameFiles) = ((IMessageGetter, bool))GetBaseRecord(message.FormKey, masters.Select(x => x?.Messages), mod.Messages);

                    //merge buttons
                    patchMessage.MenuButtons.SetTo(MergeMessageButtons(message.MenuButtons, baseRecord.MenuButtons, patchMessage.MenuButtons));
                }
            }
        }
        public static void patchMagicEffects(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching magic effects...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.MagicEffects.Select(x => x.FormKey).ToList();
                List<IMagicEffectGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IMagicEffectGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IMagicEffectGetter magicEffect in mod.MagicEffects) {
                    if (alreadyProcessed.Contains(magicEffect.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(magicEffect.FormKey);
                    IMagicEffectGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == magicEffect.FormKey).First();
                    MagicEffect patchMagicEffect = state.PatchMod.MagicEffects.GetOrAddAsOverride(winningOverrideRecord);

                    //find base magic effect in files
                    (IMagicEffectGetter baseRecord, bool inBaseGameFiles) = ((IMagicEffectGetter, bool))GetBaseRecord(magicEffect.FormKey, masters.Select(x => x?.MagicEffects), mod.MagicEffects);

                    //var test = mods.Select(x => x.MagicEffects));
                    //override base cost
                    patchMagicEffect.BaseCost = magicEffect.BaseCost;

                    //merge scripts
                    patchMagicEffect.VirtualMachineAdapter = MergeVMAdapters(magicEffect.VirtualMachineAdapter, baseRecord, patchMagicEffect.VirtualMachineAdapter);

                    //override archetype
                    patchMagicEffect.Archetype = magicEffect.Archetype.DeepCopy();

                    //override actor value
                    patchMagicEffect.SecondActorValue = magicEffect.SecondActorValue;

                    //append conditions
                    //patchMagicEffect.Conditions.SetTo(AppendConditions(magicEffect.Conditions, patchMagicEffect.Conditions));

                    //override conditions
                    patchMagicEffect.Conditions.Clear();
                    foreach (IConditionGetter condition in magicEffect.Conditions) {
                        patchMagicEffect.Conditions.Add(condition.DeepCopy());
                    }

                    //override description
                    patchMagicEffect.Description = magicEffect.Description?.DeepCopy();

                    //override keywords
                    if (magicEffect.Keywords is not null) {
                        if (patchMagicEffect.Keywords is null) {
                            patchMagicEffect.Keywords = new();
                        }
                        patchMagicEffect.Keywords.SetTo(magicEffect.Keywords);
                    }

                    //override flags
                    patchMagicEffect.Flags = magicEffect.Flags;

                    //override names
                    patchMagicEffect.Name = magicEffect.Name?.DeepCopy();

                    //override second AV weight
                    patchMagicEffect.SecondActorValueWeight = magicEffect.SecondActorValueWeight;

                    //override taper
                    patchMagicEffect.TaperCurve = magicEffect.TaperCurve;
                    patchMagicEffect.TaperWeight = magicEffect.TaperWeight;
                    patchMagicEffect.TaperDuration = magicEffect.TaperDuration;

                    //override resist value
                    patchMagicEffect.ResistValue = magicEffect.ResistValue;

                }
            }
        }
        public static void patchMiscItems(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching items...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.MiscItems.Select(x => x.FormKey).ToList();
                List<IMiscItemGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IMiscItemGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IMiscItemGetter miscItem in mod.MiscItems) {
                    if (alreadyProcessed.Contains(miscItem.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(miscItem.FormKey);
                    IMiscItemGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == miscItem.FormKey).First();
                    MiscItem patchMiscItem = state.PatchMod.MiscItems.GetOrAddAsOverride(winningOverrideRecord);

                    //find base misc item in files
                    (IMiscItemGetter baseRecord, bool inBaseGameFiles) = ((IMiscItemGetter, bool))GetBaseRecord(miscItem.FormKey, masters.Select(x => x?.MiscItems), mod.MiscItems);

                    //merge keywords
                    if(miscItem.Keywords is not null ) {
                        if (patchMiscItem.Keywords is null) {
                            patchMiscItem.Keywords = new();
                        }
                        patchMiscItem.Keywords.SetTo(MergeKeywordList(miscItem.Keywords, baseRecord.Keywords, patchMiscItem.Keywords));
                    }

                    //override sounds
                    patchMiscItem.PickUpSound.SetTo(miscItem.PickUpSound);
                    patchMiscItem.PutDownSound.SetTo(miscItem.PutDownSound);

                    //override vlaue
                    patchMiscItem.Value = miscItem.Value;

                    //override name
                    patchMiscItem.Name = miscItem.Name?.DeepCopy();

                    //override weight
                    patchMiscItem.Weight = miscItem.Weight;
                }
            }
        }
        public static void patchNpcs(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching NPCs...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Npcs.Select(x => x.FormKey).ToList();
                List<INpcGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<INpcGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (INpcGetter npc in mod.Npcs) {
                    if (alreadyProcessed.Contains(npc.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(npc.FormKey);
                    INpcGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == npc.FormKey).First();
                    Npc patchNpc = state.PatchMod.Npcs.GetOrAddAsOverride(winningOverrideRecord);

                    //find base npc in files
                    (INpcGetter baseRecord, bool inBaseGameFiles) = ((INpcGetter, bool))GetBaseRecord(npc.FormKey, masters.Select(x => x?.Npcs), mod.Npcs);

                    //merge items
                    if (patchNpc.Items is null) {
                        patchNpc.Items = new();
                    }
                    patchNpc.Items.SetTo(MergeContainerEntryList(npc.Items, baseRecord.Items, patchNpc.Items));
                }
            }
        }
        public static void patchPerks(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching perks...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                foreach (IPerkGetter perk in mod.Perks) {
                    if (alreadyProcessed.Contains(perk.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(perk.FormKey);
                    //override everything. Perks don't make sense to merge in any way.
                    Perk patchPerk = state.PatchMod.Perks.GetOrAddAsOverride(perk);
                }
                alreadyProcessed = new();
                foreach (IActorValueInformationGetter avi in mod.ActorValueInformation) {
                    if (alreadyProcessed.Contains(avi.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(avi.FormKey);
                    //IActorValueInformationGetter winningOverrideRecord = winningOverrides1.Where(x => x.FormKey == avi.FormKey).First();
                    //override everything. Perk trees don't make sense to merge in any way.
                    ActorValueInformation patchAvi = state.PatchMod.ActorValueInformation.GetOrAddAsOverride(avi);
                }
            }
        }
        public static void patchQuests(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching quests...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Quests.Select(x => x.FormKey).ToList();
                List<IQuestGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<IQuestGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (IQuestGetter quest in mod.Quests) {
                    if (alreadyProcessed.Contains(quest.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(quest.FormKey);
                    IQuestGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == quest.FormKey).First();
                    Quest patchQuest = state.PatchMod.Quests.GetOrAddAsOverride(winningOverrideRecord);
                    //find base container in files
                    (IQuestGetter baseRecord, bool inBaseGameFiles) = ((IQuestGetter, bool))GetBaseRecord(quest.FormKey, masters.Select(x => x?.Quests), mod.Quests);

                    //Merge scripts

                    patchQuest.VirtualMachineAdapter = MergeQuestVMAdapters(quest.VirtualMachineAdapter, baseRecord, patchQuest.VirtualMachineAdapter);

                }
            }
        }
        public static void patchSpells(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching spells...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Spells.Select(x => x.FormKey).ToList();
                List<ISpellGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<ISpellGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (ISpellGetter spell in mod.Spells) {
                    if (alreadyProcessed.Contains(spell.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(spell.FormKey);
                    ISpellGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == spell.FormKey).First();
                    Spell patchSpell = state.PatchMod.Spells.GetOrAddAsOverride(winningOverrideRecord);
                    //find base container in files
                    (ISpellGetter baseRecord, bool inBaseGameFiles) = ((ISpellGetter, bool))GetBaseRecord(spell.FormKey, masters.Select(x => x?.Spells), mod.Spells);

                    //override name
                    patchSpell.Name = spell.Name?.DeepCopy();

                    //override type
                    patchSpell.Type= spell.Type;

                    //override effects. In some cases it may be desireable to bring over modifications to vanilla effects, but that sounds hard.
                    patchSpell.Effects.Clear();
                    foreach (IEffectGetter e in spell.Effects) {
                        patchSpell.Effects.Add(e.DeepCopy());
                    }
                }
            }
        }
        public static void patchTrees(IPatcherState<ISkyrimMod, ISkyrimModGetter> state, List<String> modNames, List<ISkyrimModGetter> mods) {
            System.Console.WriteLine("Patching trees...");
            int modIndex = -1;
            List<FormKey> alreadyProcessed = new();
            foreach (ISkyrimModGetter mod in mods) {
                modIndex++;
                System.Console.WriteLine("Patching mod: " + modNames[modIndex]);
                List<FormKey> modFormIDs = mod.Trees.Select(x => x.FormKey).ToList();
                List<ITreeGetter> winningOverrides = state.LoadOrder.PriorityOrder.WinningOverrides<ITreeGetter>().Where(x => modFormIDs.Contains(x.FormKey)).ToList();
                List<ISkyrimModGetter?> masters = new();
                mod.MasterReferences.Reverse().ForEach(x => masters.Add(state.LoadOrder.getModByFileName(x.Master.ToString())));
                foreach (ITreeGetter tree in mod.Trees) {
                    if (alreadyProcessed.Contains(tree.FormKey)) {
                        continue;
                    }
                    alreadyProcessed.Add(tree.FormKey);
                    ITreeGetter winningOverrideRecord = winningOverrides.Where(x => x.FormKey == tree.FormKey).First();
                    Tree patchTree = state.PatchMod.Trees.GetOrAddAsOverride(winningOverrideRecord);

                    //find base tree in files
                    (ITreeGetter baseRecord, bool inBaseGameFiles) = ((ITreeGetter, bool))GetBaseRecord(tree.FormKey, masters.Select(x => x?.Trees), mod.Trees);

                    System.Console.WriteLine("Patching tree: " + tree.Name);

                    //override name
                    patchTree.Name = tree.Name?.DeepCopy();

                    //override ingredient
                    patchTree.Ingredient.SetTo(tree.Ingredient);

                    //merge vm adapters
                    patchTree.VirtualMachineAdapter = MergeVMAdapters(tree.VirtualMachineAdapter, baseRecord, patchTree.VirtualMachineAdapter);
                }
            }
        }
    }
}
