using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Skyrim.Records;
using Noggog;
using static Mutagen.Bethesda.Skyrim.Furniture;
using DynamicData;
using Mutagen.Bethesda.Strings;

namespace CACO_Patcher.Utilities {

    internal class LeveledListUtilities {
        /// <summary>
        /// Struct <c>_intListDiff</c> is a class representing a transformation that can be applied to a leveled list. Intended for use in DiffDict, generated by _calculateSmallestTransformationBewteenLists.
        /// </summary>
        private class _intListDiff {
            public _intListDiff() {
                additions = new();
                removals = new();
                modifications = new();
            }
            public _intListDiff(_intListDiff toCopy) {
                additions = new(toCopy.additions ?? new List<(int, int)>());
                removals = new(toCopy.removals ?? new List<(int, int)>());
                modifications = new(toCopy.modifications ?? new List<((int, int), (int, int))>());
            }
            public _intListDiff Merge(_intListDiff mergeWith) {
                _intListDiff mergeWithCopy = new _intListDiff(mergeWith);
                _intListDiff result = new();
                //merge modifications
                foreach (((int count, int level) from, (int count, int level) to) modification in modifications) {
                    //if an exact copy of this modification exists in the list to merge with
                    //add it to the merge and remove it from mergeWithCopy 
                    if (mergeWithCopy.modifications.Contains(modification)) {
                        mergeWithCopy.modifications.Remove(modification);
                        result.modifications.Add(modification);
                        continue;
                    }
                    //if mergeWith modifies the same value, accept the larger change
                    //copy again to avoid modification while iterating
                    _intListDiff mergeWithCopy1 = new _intListDiff(mergeWithCopy);
                    foreach (((int count, int level) from, (int count, int level) to) mergeWithCopyModification in mergeWithCopy.modifications) {
                        if (mergeWithCopyModification.Item1.Item1 == modification.Item1.Item1) {
                            int count = Math.Abs(modification.from.count - mergeWithCopyModification.to.count) > Math.Abs(modification.from.count - modification.to.count) ? mergeWithCopyModification.to.count : modification.to.count;
                            int level = Math.Abs(modification.from.level - mergeWithCopyModification.to.level) > Math.Abs(modification.from.level - modification.to.level) ? mergeWithCopyModification.to.level : modification.to.level;
                            result.modifications.Add((modification.from, (count, level)));
                            mergeWithCopy1.modifications.Remove(mergeWithCopyModification);
                            //break after finding one match
                            break;
                        }
                    }
                    //set copy to new copy to reflect changes
                    mergeWithCopy = mergeWithCopy1;
                }
                //add anything left in mergeWithCopy.modifications
                foreach (((int count, int level), (int count, int level)) modification in modifications) {
                    result.modifications.Add(modification);
                }
                //merge additions and removals
                foreach ((int count, int level) addition in additions) {
                    //removels cancel out additions
                    if (mergeWithCopy.removals.Contains(addition)) {
                        mergeWithCopy.removals.Remove(addition);
                        continue;
                    }
                    result.additions.Add(addition);
                }
                foreach ((int count, int level) removal in removals) {
                    //additions cancel out removals
                    if (mergeWithCopy.additions.Contains(removal)) {
                        mergeWithCopy.additions.Remove(removal);
                        continue;
                    }
                    result.removals.Add(removal);
                }
                return result;
            }
            public List<((int count, int level) from, (int count, int level) to)> modifications;
            public List<(int, int)> removals;
            public List<(int, int)> additions;
        }
        /// <summary>
        /// Type <c>_leveledItemEntryDict</c> is a dictionary relating a key ILeveledItemEntryGetter to an integer value. Intended for use in ListDict.
        /// </summary>
        private class _leveledItemEntryDict : Dictionary<ILeveledItemEntryGetter, int> { }
        /// <summary>
        /// Type <c>DiffDict</c> is a dictionary relating FormKey to Tuples of type (bool completelyRemoved, _intListDiff transformation). Intended to represent differences between leveled lists.
        /// </summary>
        private class DiffDict : Dictionary<FormKey, (bool completelyRemoved, _intListDiff transformation)> {
            public DiffDict(DiffDict toCopy) {
                foreach (KeyValuePair<FormKey, (bool completelyRemoved, _intListDiff transformation)> kv_pair in toCopy) {
                    Add(kv_pair.Key, kv_pair.Value);
                }
            }
            public DiffDict() { }
        }
        /// <summary>
        /// Type <c>DiffDict</c> is a dictionary relating FormKey to List<(int count, int level)>. Intended to represent leveled lists.
        /// </summary>
        private class ListDict : Dictionary<FormKey, List<(int count, int level)>> {
            public ListDict(IReadOnlyList<ILeveledItemEntryGetter>? list) {
                foreach (ILeveledItemEntryGetter entry in list ?? new ExtendedList<ILeveledItemEntryGetter>()) {
                    if (entry.Data is not null) {
                        //get any existing data on this FormKey
                        this.TryGetValue(entry.Data.Reference.FormKey, out List<(int, int)>? formKeyEntries);
                        formKeyEntries ??= new();
                        //add that plus one
                        formKeyEntries.Add((entry.Data.Count, entry.Data.Level));
                        //this.Add(entry.Data.Reference.FormKey, formKeyEntries);
                        this[entry.Data.Reference.FormKey] = formKeyEntries;
                    }
                }
            }
        }
        /// <summary>
        /// return the closest entry by count in list getFrom to int num.
        /// </summary>
        /// <param name="num">The number to use</param>
        /// <param name="getFrom">The list to look in</param>
        /// <returns>
        /// (int count, int level) the closest match to target found in in getFrom
        /// </returns>
        private static (int count, int level) _getClosestFromList((int count, int level) target, List<(int count, int level)> getFrom) {
            //return getFrom.Aggregate((x, y) => Math.Abs(x - num) < Math.Abs(y - num) ? x : y);
            (int count, int level)? closest = null;
            foreach ((int count, int level) val in getFrom) {
                if (closest is null) {
                    closest = val;
                    continue;
                }
                if (Math.Abs(val.count - target.count) < Math.Abs(closest.Value.count - target.count)) {
                    closest = val;
                }
            }
            //default value may cause issues?
            return closest is null ? new() : closest.Value;
        }
        /// <summary>
        /// return _intListDiff? representing the smallest transformation required to be applied to list a to create list b.
        /// </summary>
        /// <param name="a">The list to transform from</param>
        /// <param name="b">The list to transform into</param>
        /// <returns>
        /// _intListDiff? the minimal transformation from list a to b
        /// </returns>
        private static _intListDiff? _calculateSmallestTransformationBewteenLists(List<(int, int)> a, List<(int, int)> b) {
            //copy both lists so we can iterate and remove
            List<(int, int)> a_copy = new List<(int, int)>(a);
            List<(int, int)> b_copy = new List<(int, int)>(b);
            _intListDiff? result = new();
            //Remove any duplicates
            foreach ((int, int) val in a) {
                if (b_copy.Contains(val)) {
                    a_copy.Remove(val);
                    b_copy.Remove(val);
                }
            }
            //calculate modifications and removals
            List<(int, int)> a_copy1 = new List<(int, int)>(a_copy);
            foreach ((int, int) val in a_copy) {
                //if b_copy is empty, mark as removed
                if (b_copy.Count == 0) {
                    result.removals.Add(val);
                    a_copy1.Remove(val);
                } //Else, mark this value and the closest value in b_copy for modification
                else {
                    (int count, int level) closestInB = _getClosestFromList(val, b_copy);
                    result.modifications.Add((val, closestInB));
                    b_copy.Remove(closestInB);
                }
            }
            //anything left in b_copy is an addition
            foreach ((int count, int level) val in b_copy) {
                result.additions.Add(val);
            }
            if (!(result.removals.Count == 0 && result.additions.Count == 0 && result.modifications.Count == 0)) {
                return result;
            }
            return null;
        }
        /// <summary>
        /// Subtract dict2 from dict1.
        /// </summary>
        /// <param name="dict1"></param>
        /// <param name="dict2"></param>
        /// <returns>
        /// DiffDict
        /// </returns>
        /// <remarks>
        /// </remarks>
        private static DiffDict _subtractDicts(ListDict dict1, ListDict dict2) {
            DiffDict diff = new();
            //calculate necessary transformations and add them to diff
            foreach (KeyValuePair<FormKey, List<(int, int)>> kv_pair in dict1) {
                //get associated count list, if it exists, and calculate transformation between it and the list from dict1
                dict2.TryGetValue(kv_pair.Key, out List<(int count, int level)>? dict2_counts);
                _intListDiff? transformation = _calculateSmallestTransformationBewteenLists(dict2_counts ?? new List<(int, int)>(), kv_pair.Value);
                //diff.Add(kv_pair.Key, (false, transformation));
                if (transformation is not null) {
                    diff[kv_pair.Key] = (false, transformation);
                }
            }
            //any FormKey in dict2 that doesn't already exist in diff is a complete removal- mark them as such 
            foreach (KeyValuePair<FormKey, List<(int count, int level)>> kv_pair in dict2) {
                if (dict1.ContainsKey(kv_pair.Key)) {
                    continue;
                }
                diff[kv_pair.Key] = (true, new());
            }
            return diff;
        }
        /// <summary>
        /// Merges diff dicts- removes any FormKey flagged as completelyRemoved, combines changes of different signs, takes the larger change of those with the same sign.
        /// </summary>
        /// <param name="dict1"></param>
        /// <param name="dict2"></param>
        /// <returns>
        /// DiffDict
        /// </returns>
        /// <remarks>
        /// </remarks>
        private static DiffDict _mergeDiffDicts(DiffDict dict1, DiffDict dict2) {
            DiffDict merged = new();
            //DiffDict dict2_copy = new(dict2);
            //merge any in dict1, or dict1 and dict2 after merging transformations
            foreach (KeyValuePair<FormKey, (bool completelyRemoved, _intListDiff transformation)> kv_pair in dict2) {
                if (dict1.ContainsKey(kv_pair.Key)) {
                    dict1.TryGetValue(kv_pair.Key, out var dict2_value);
                    dict1.Remove(kv_pair.Key);
                    //if either removes this completely, accept that
                    if (kv_pair.Value.completelyRemoved || dict2_value.completelyRemoved) {
                        merged[kv_pair.Key] = (true, new());
                        continue;
                    }
                    merged[kv_pair.Key] = (false, kv_pair.Value.transformation.Merge(dict2_value.transformation));
                }
                else {
                    if (kv_pair.Value.completelyRemoved) {
                        merged[kv_pair.Key] = (true, new());
                        continue;
                    }
                    merged[kv_pair.Key] = (false, kv_pair.Value.transformation);
                }
            }
            //add any left in dict2
            foreach (KeyValuePair<FormKey, (bool completelyRemoved, _intListDiff transformation)> kv_pair in dict1) {
                if (kv_pair.Value.completelyRemoved) {
                    merged[kv_pair.Key] = (true, new());
                    continue;
                }
                merged[kv_pair.Key] = (false, kv_pair.Value.transformation);
            }
            return merged;
        }
        /// <summary>
        /// resolves dict2 into dict 1.
        /// </summary>
        /// <param name="dict1"></param>
        /// <param name="dict2"></param>
        /// <returns>
        /// ListDict
        /// </returns>
        /// <remarks>
        /// </remarks>
        private static ListDict _applyDiffDict(ListDict dict1, DiffDict dict2) {
            //apply removals
            foreach (KeyValuePair<FormKey, (bool completelyRemoved, _intListDiff transformation)> kv_pair in dict2) {
                //remove and continue if this key is completely removed
                if (kv_pair.Value.completelyRemoved) {
                    dict1.Remove(kv_pair.Key);
                    continue;
                }
                dict1.TryGetValue(kv_pair.Key, out var list_values);
                if (list_values is null) {
                    list_values = new();
                }
                //do removals first
                foreach ((int, int) removal in kv_pair.Value.transformation.removals) {
                    list_values?.Remove(removal);
                }
                //then modifications
                foreach (((int, int) original, (int, int) replaceWith) modification in kv_pair.Value.transformation.modifications) {
                    if (list_values?.Contains(modification.original) ?? false) {
                        list_values?.Replace(modification.original, modification.replaceWith);
                    }
                }
                //then additions
                foreach ((int, int) addition in kv_pair.Value.transformation.additions) {
                    list_values?.Add(addition);
                }
                dict1[kv_pair.Key] = list_values;
            }
            return dict1;
        }
        /// <summary>
        /// Merges lists of LeveledItemEntry.
        /// </summary>
        /// <param name="listToMerge">The list to merge</param>
        /// <param name="baseRecordList">The list in the first occurrence (earliest in the load-order) of the object we are patching</param>
        /// <param name="patchList">The list to merge into</param>
        /// <returns>
        /// ExtendedList<LeveledItemEntry>?
        /// </returns>
        /// <remarks>
        /// reeeeeeeeeeeeee
        /// </remarks>
        public static ExtendedList<LeveledItemEntry>? MergeLeveledList(IReadOnlyList<ILeveledItemEntryGetter>? listToMerge, IReadOnlyList<ILeveledItemEntryGetter>? baseRecordList, ExtendedList<LeveledItemEntry>? patchList) {
            if (listToMerge is null) {
                System.Console.WriteLine("No LeveledList to merge");
                return patchList;
            }
            if (patchList is null) {
                patchList = new();
                foreach (ILeveledItemEntryGetter item in listToMerge) {
                    patchList.Add(item.DeepCopy());
                }
                System.Console.WriteLine("overriding null LeveledList");
                return patchList;
            }
            if (patchList.Count == 0) {
                Console.WriteLine("patch leveled item has no items: ");
            }
            //merge into patch
            //build dictionaries of records and number of occurrences
            //ListDict winningOverrideFormCache = new(winningOverrideList);
            ListDict toMergeFormCache = new(listToMerge);
            ListDict baseRecordFormCache = new(baseRecordList);
            ListDict patchFormCache = new(patchList);

            //diff1=toMerge minus base
            DiffDict diff1 = _subtractDicts(toMergeFormCache, baseRecordFormCache);
            //diff2=patch minus base
            DiffDict diff2 = _subtractDicts(patchFormCache, baseRecordFormCache);
            if (diff2.Keys.Count == 0) {
                Console.WriteLine("patch leveled item unchanged from base: ");
            }
            //mergepatch=diff1 merge diff2
            DiffDict diffdiff = _mergeDiffDicts(diff1, diff2);
            //result=patch apply mergePatch
            ListDict applied = _applyDiffDict(baseRecordFormCache, diffdiff);
            //write sum to result list
            ExtendedList<LeveledItemEntry> result = new();
            foreach (KeyValuePair<FormKey, List<(int count, int level)>> kv_pair in applied) {
                foreach ((int count, int level) data in kv_pair.Value) {
                    LeveledItemEntry leveledItemEntry = new();
                    leveledItemEntry.Data = new();
                    leveledItemEntry.Data.Count = (short)data.count;
                    leveledItemEntry.Data.Reference = new FormLink<IItemGetter>(kv_pair.Key);
                    //TODO: add level awareness
                    leveledItemEntry.Data.Level = (short)data.level;
                    result.Add(leveledItemEntry);
                }
            }
            return result;
        }
    }
}
